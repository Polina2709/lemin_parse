/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pathfinder.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jconcent <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/09/10 14:24:49 by jconcent          #+#    #+#             */
/*   Updated: 2020/10/07 10:25:22 by jconcent         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "lem_in.h"

/*
**	Add the solution generated by the pathfinder to the array of solutions
*/

t_array	**append_solutions(t_array **sols, int nb_sols, t_array sol)
{
	t_array **temp;

	if ((temp = (t_array**)malloc(sizeof(t_array*) * nb_sols + 1)) == NULL)
		return (sols);
	if (nb_sols > 0)
	{
		ft_memcpy(temp, sols, sizeof(t_array*) * nb_sols);
		free(sols);
	}
	sols = temp;
	if ((sols[nb_sols] = (t_array*)malloc(sizeof(t_array))) == NULL)
		return (sols);
	ft_memcpy(sols[nb_sols], &sol, sizeof(t_array));
	if ((sols[nb_sols]->data = (int*)malloc(sizeof(int) * sol.size)) == NULL)
		return (sols);
	ft_memcpy(sols[nb_sols]->data, sol.data, sizeof(int) * sol.size);
	return (sols);
}

/*
**	Checking for repeat visits to the node
*/

int		in_solutions(t_array *sol, int node)
{
	int i;

	i = 0;
	while (i < (int)sol->size)
	{
		if (CONTENT_ARRAY(sol, i) == node)
			return (1);
		i++;
	}
	return (0);
}

/*
**	Looking for the next matching node
*/

int		get_min_path(int **routetab, int size, int row, int end)
{
	int col;
	int min;
	int node;

	col = 0;
	min = size + 1;
	node = size;
	while (col < size)
	{
		if (routetab[row][col] == 1 && routetab[col][end] < min)
		{
			min = routetab[end][col];
			node = col;
		}
		col++;
	}
	return (node);
}

/*
**	This is recursive function that generates one complete solution
**	until the end index is inserted into the structure (sol).
*/

int		pathfinder(int ***routetab, int size, t_array *sol, int end)
{
	int node;

	node = get_min_path(*routetab, size,
						CONTENT_ARRAY(sol, sol->size - 1), end);
	if (node == end)
	{
		if (sol->size == 1)
			(*routetab)[CONTENT_ARRAY(sol, sol->size - 1)][end] = size + 1;
		ft_array_add(sol, &node, 1);
		return (1);
	}
	while (node < size && (*routetab)[end][node] < size + 1 &&
										!in_solutions(sol, node))
	{
		(*routetab)[CONTENT_ARRAY(sol, sol->size - 1)][end] = size + 1;
		ft_array_add(sol, &node, 1);
		(*routetab)[end][node] = size + 1;
		if (pathfinder(routetab, size, sol, end))
			return (1);
		ft_array_pop(sol, 1);
		node = get_min_path(*routetab, size,
							CONTENT_ARRAY(sol, sol->size - 1), end);
	}
	return (0);
}

/*
**	We fill in structure (solutions) with all possible solutions and
**	return number of such solutions.
*/

int		run_pathfinder(int **route, t_array ***sol, t_node *r, t_lm_data *lem)
{
	t_array	sols;
	int		nb_sols;
	int		turns;
	int		start;

	sols = INIT_ARRAY(int);
	nb_sols = 0;
	turns = 0;
	start = get_ind(r, lem, lem->start);
	ft_array_add(&sols, &start, 1);
	while (pathfinder(&route, lem->nb_rooms, &sols, get_ind(r, lem, lem->end)))
	{
		*sol = append_solutions((*sol), nb_sols++, sols);
		if (turns_counter((*sol), lem->nb_ants, nb_sols) > turns && turns != 0)
		{
			ft_array_clear((*sol)[--nb_sols]);
			free((*sol)[nb_sols]);
		}
		turns = turns_counter((*sol), lem->nb_ants, nb_sols);
		ft_array_clear(&sols);
		sols = INIT_ARRAY(int);
		ft_array_add(&sols, &start, 1);
	}
	ft_array_clear(&sols);
	return (nb_sols);
}
